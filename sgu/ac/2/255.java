// SGU255. Winsock 3 Beta 
/*
6 2
10 4
18 7
34 11
66 16
130 22
258 29
514 37
1026 46
2050 56
4098 67
8194 79
16386 92
32770 106
65538 121

2^n+2 n*(n-1)/2+1
*/
import java.util.*;

public class Solution {
	static {
		/*
		int[] ones = new int[1 << 20];
		for (int i = 1; i < ones.length; ++i) {
			ones[i] = ones[i >> 1] + (i & 1);
		}
		ones[0] = (ones[0] == 3 ? 1 : 0);
		for (int i = 1; i < ones.length; ++i) {
			ones[i] = ones[i - 1] + (ones[i] == 3 ? 1 : 0);
		}
		for (int i = 1; i < 100000; ++i) {
			if (ones[i + i] - ones[i] != ones[i + i - 2] - ones[i - 1] &&
				ones[i + i] - ones[i] != ones[i + i + 2] - ones[i + 1]) {
				System.out.println(i + " " + (ones[i + i] - ones[i]));
			}
		}
		*/
	}

	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		int re = in.nextInt();
		for (int ri = 1; ri <= re; ++ri) {
			long n = in.nextLong();
			long m = n > 1 ? (long)Math.sqrt(2 * (n - 1)) : -10;
			System.out.println(m * (m + 1) == 2 * (n - 1) ? "YES" : "NO");
		}
	}
}

/*
Описание алгоритма:
*/

//ID: 	Date'n'Time: 	Name: 	Task: 	.Ext: 	Status:  	Time:  	Memory:
//1079118	20.09.10 17:09	watashi	255 	.JAVA	Accepted 	30 ms	0 kb

/*
SGU 255. Winsock 3 Beta 解题报告

先简要说一下本题的意思。（非原题意思，但不影响解题SGU <wbr>255. <wbr>Winsock <wbr>3 <wbr> Beta <wbr>解题报告）

有一个防火墙，它有一个参数K。它只允许数据从端口K+1到2K中那些端口号二进制形式有且只有3个 1的端口通过。比如当K=6时，端口7，11可以通过，因为7的2进制为111，11的2进制为1011。假设我们现在是黑客，目前不知道K的大小，于是我们给这个防火墙的端口1~无穷大都发送了数据包，当然只有可以通过的端口才会回复这个数据包。现在我们只知道回复数据包的个数M，问我们是否可以确定K 的值，即K是否唯一。

我们先把解决一个看起来会简单点的问题。假设我们现在是防火墙，我们知道K的值，求我们回复的数据包个数M。

将K转化为二进制形式，我们记住最右边那3个1的位置（先假设K有3个或3个以上的1），记为 b1,b2,b3(b1>b2>b3)。比如K=101101(2)，此时b1=6,b2=4,b3=3。根据排列组合的知识，所有小于等于 K的数字中符合题意的数字的个数为C(3,b1-1)[在后面的b1-1位中任取3位]+C(2,b2-1) [第1个1取b1,在后面的b2-1位中任取2位]+C(1,b3-1) [第1个1取b1, 第2个1取b2,在后面的b1-1位中取1位]+1[分别取b1,b2,b3]。同理所有小于等于2*K的数字中符合题意的数字的个数为 C(3,b1)+C(2,b2)+C(1,b3)+1，于是所有在K+1到2*K之间符合题意的数字的个数为 C(3,b1)+C(2,b2)+C(1,b3)+1-(C(3,b1-1)+C(2,b2-1)+C(1,b3-1)+1)，化简得 C(2,b1-1)+ C(1,b2-1)+ C(0,b3-1)，即(b1-1)*(b1-2)/2+b2。

当K中只有2个1时，也就是说b3不存在。此时同上述分析过程可得符合题意的数字有(b1-1)*(b1-2)/2+b2-1个。

当K中只有1个1时，也就是b2,b3都不存在。此时同上述分析过程可得符合题意的数字有(b1-1)*(b1-2)/2个。

这个时候我们可以根据以上得到的结论，分别讨论，反解出K，看看是否唯一。（因为重复很多，所以分析方法不只一种，以下仅为参考）

对于第一种情况，当b3存在时，因为b3并不影响M的值，当且仅当b2=2，b3的值才能唯一。此时 M值为(b1-1)*(b1-2)/2+2。但是这个解与b3不存在、b2=3时相同。心细的读者一定会问当b1=3怎么办？b1=3时，计算得M值为 3，等于当b1=4、b2b3不存在的情况。

对于第三种情况，当b2b3都不存在的情况，我们发现它和b1'=b1,b2'=1,b3'不存在的情况的解是一样的。(b1-1)*(b1-2)/2=(b1-2)*(b1-3)/2+b1-2。

只有第二种情况中，当b2>=3时，我们发现它和b1'=b1,b2'=b2-1,b3'存在的情况解是一样的。当b2=1时，和第三种情况重复。只有当b2=2时才没有重复。此时K解的形式为(b1-1)*(b1-2)/2+1。(b1>=3)

于是问题转化到了输入m，求(x-1)*(x-2)/2+1=m是否有大于等于3的正整数解。

由求根公式，得较大根x=(3+sqrt(8*m-7))/2（小根必定小于3，舍去），看是否为大于等于3的正整数即可解决问题。
*/

